input {
	lumberjack {
	  # The port to listen on
	  port => 5043
	  # The paths to your ssl cert and key, these are from the perspective of the container
	  ssl_certificate => "/usr/local/serviced/resources/logstash/logstash-forwarder.crt"
	  ssl_key => "/usr/local/serviced/resources/logstash/logstash-forwarder.key"
	}
	tcp {
		port => 5042
		codec => "json_lines"
	}
}


# 
filter {
# NOTE the filters are generated from the service definitions

if [type] == "zauth_eventlog" 
 {
  if [message] == "------" {
    drop { }
} 
}
if [type] == "zauth_eventlog" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zauth_access_logs" 
 {
  mutate {
    gsub => [ "message", "\[", "" ]
    gsub => [ "message", "\]", "" ]
}
grok {
    # 127.0.0.1 - Anonymous [03/Jan/2014:12:37:11 -0500] \"POST /zport/dmd/jobs_router HTTP/1.0\" 200 544 \"http://localhost:8080/zport/dmd/itinfrastructure\" \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36\
     match => [ "message", "%{IP:client} - %{WORD:user} %{HTTPDATE:date} %{QUOTEDSTRING:method} %{NUMBER:response} %{NUMBER:duration} %{QUOTEDSTRING:referrer} %{GREEDYDATA:agent}" ]
}
mutate {
    gsub => [ "referrer", "\"", "" ]
    gsub => [ "agent", "\"", "" ]
    gsub => [ "method", "\"", "" ]
} 
}
if [type] == "zeneventd" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "centralquery" 
 {
  # strip the brackets out of the timestamps so that it parses easier
mutate {
    gsub => [ "message", "\[", "" ]
    gsub => [ "message", "\]", "" ]
}

# TODO verify that this is true
multiline {
  pattern => "^[!]"
  what => "previous"
}
# DEBUG [2014-01-02 11:49:24,788] org.zenoss.metrics.reporter.ZenossMetricsReporter: Posting 593 metrics
grok {
  match => [ "message", "%{LOGLEVEL:loglevel} %{TIMESTAMP_ISO8601} %{USERNAME:logger}"]
} 
}
if [type] == "metricconsumer" 
 {
  # strip the brackets out of the timestamps so that it parses easier
mutate {
    gsub => [ "message", "\[", "" ]
    gsub => [ "message", "\]", "" ]
}

# TODO verify that this is true
multiline {
  pattern => "^[!]"
  what => "previous"
}
# DEBUG [2014-01-02 11:49:24,788] org.zenoss.metrics.reporter.ZenossMetricsReporter: Posting 593 metrics
grok {
  match => [ "message", "%{LOGLEVEL:loglevel} %{TIMESTAMP_ISO8601} %{USERNAME:logger}"]
} 
}
if [type] == "zenjobs" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zenprocess" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zenpython" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zenstatus" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zencommand" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zenjmx" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zenmodeler" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zenperfsnmp" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zenping" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zensyslog" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zentrap" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zope_eventlog" 
 {
  if [message] == "------" {
    drop { }
} 
}
if [type] == "zope_eventlog" 
 {
  # Matches lines of the form: 2013-10-31 06:10:54,292 INFO zen.zenutils.functioncache: initializing FunctionCache

# assuming if it doesn't start with a number (date) then it is a newline
# TODO: probably a better regex for determining if it is a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# extract the timestamp, loglevel and logger from the message
grok {
   match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{USERNAME:logger}: " ]
} 
}
if [type] == "zope_access_logs" 
 {
  mutate {
    gsub => [ "message", "\[", "" ]
    gsub => [ "message", "\]", "" ]
}
grok {
    # 127.0.0.1 - Anonymous [03/Jan/2014:12:37:11 -0500] \"POST /zport/dmd/jobs_router HTTP/1.0\" 200 544 \"http://localhost:8080/zport/dmd/itinfrastructure\" \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36\
     match => [ "message", "%{IP:client} - %{WORD:user} %{HTTPDATE:date} %{QUOTEDSTRING:method} %{NUMBER:response} %{NUMBER:duration} %{QUOTEDSTRING:referrer} %{GREEDYDATA:agent}" ]
}
mutate {
    gsub => [ "referrer", "\"", "" ]
    gsub => [ "agent", "\"", "" ]
    gsub => [ "method", "\"", "" ]
} 
}
if [type] == "zenossaudit" 
 {
  # similar to pythondaemon but it doesn't have a logger
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}
# 2014-01-14 14:09:43,922 INFO success: zenperfpub entered RUNNING state, process has stayed up for > than 5 seconds (startsecs)
grok {
    match => [ "message", "%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel}" ]
} 
}
if [type] == "zeneventserver" 
 {
  # new lines start with a date
multiline {
    pattern => "^[A-Za-z|\s]"
    what => "previous"
}

# drop the brackets to make parsing easier
mutate {
    gsub => [ "message", "\[", "" ]
    gsub => [ "message", "\]", "" ]
}
# 2013-10-31T06:52:44.215 [INDEXER_EVENT_SUMMARY] ERROR org.springframework.transaction.interceptor.TransactionInterceptor - Application exception overridden by rollback exception
grok {
    match => [ "message", "%{TIMESTAMP_ISO8601:time} %{WORD:component} %{LOGLEVEL:loglevel}"]
} 
}
}


output {
	stdout { debug => true}
	elasticsearch_http {
		host => "172.17.42.1"
	}
}
